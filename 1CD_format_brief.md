# Introduction #

Данная статья является доработанной версией моей статьи [Краткое описание формата файлов \*.1CD (файловых баз 1Сv8)](http://infostart.ru/public/19734)

# Details #


**Отмазки.**

Данное описание не претендует на законченность, безошибочность и понятность.

**Начало.**

Описание формата приведено в терминах языка C. Размер типа char – 1 байт, размер типа short int – 2 байта, размер типа int и unsigned int – 4 байта. Префиксом 0x обозначаются шестнадцатеричные числа.

Файлы баз `*`.1CD состоят из блоков длиной 4096 байт (0x1000). Соответственно, длина файла всегда кратна 4096.

**Блок 0.**

Нулевой блок имеет следующую структуру:
```
struct {
char sig[8]; // сигнатура “1CDBMSV8”
char ver1;
char ver2;
char ver3;
char ver4;
unsigned int length;
int unknown;
}
```
Первые 8 байт (поле sig) – сигнатура базы «1CDBMSV8».

Следующие 4 байта (поля verN) - это версия базы. На данный момент известны следующие версии:
  * «8.0.3.0» (ver1 = 8, ver2 = 0, ver3 = 3, ver4 = 0) – это базы 1C ранних тестовых версий 8.0
  * «8.0.5.0» (ver1 = 8, ver2 = 0, ver3 = 5, ver4 = 0) – это базы 1C версий 8.0
  * «8.1.0.0» (ver1 = 8, ver2 = 1, ver3 = 0, ver4 = 0) – это базы 1C версий 8.1 и ранних тестовых версий 8.2
  * «8.2.0.0» (ver1 = 8, ver2 = 2, ver3 = 0, ver4 = 0) – это базы 1C версий 8.2 до 8.2.13 включительно
  * «8.2.14.0» (ver1 = 8, ver2 = 2, ver3 = 14, ver4 = 0) – это базы 1C версий 8.2, начиная с 8.2.14 и тестовых версий 8.3

Следующие 4 байт (поле length) – длина базы (файла) в блоках.

Предназначение поля unknown неизвестно, всегда содержит 1. Предполагаю, что это адрес заголовочного блока файла свободных блоков. Но тогда остается вопрос, почему нет поля с адресом заголовочного блока корневого файла (который всегда равен 2). Возможно, что 1С полагает, что заголовочный блок корневого файла всегда следующий сразу за заголовочным блоком файла свободных блоков?

**Объекты.**

Вся остальная информация в базе хранится в объектах (файлах базы). Каждый объект состоит из одного или более блоков. У каждого объекта есть один заголовочный блок, блоки с таблицей размещения, и собственно данные. Второе и третье может отсутствовать.

Структура первого (заголовочного) блока каждого объекта такова:
```
struct {
char sig[8]; // сигнатура “1CDBOBV8”
int length; // длина содержимого объекта
int version1;
int version2;
unsigned int version;
unsigned int blocks[1018];
}
```
Первые 8 байт – сигнатура базы «1CDBOBV8».

Есть 2 типа объектов.

**Блок 1. Таблица свободных блоков.**

Первый тип объекта – это таблица свободных блоков. Такой объект в базе всегда один, и его заголовочный блок располагается всегда в блоке со смещением 1 (т.е. по адресу 0x1000). Длина данных такого объекта равна (length `*` 4) байт.

В blocks содержатся номера блоков, в которых собственно и находится содержимое таблицы свободных блоков. Значащими являются ненулевые значения в массиве blocks. Содержимое таблицы свободных блоков – это просто массив номеров свободных блоков:
```
unsigned int free_blocks[length];
```
Таким образом, в базе содержатся ровно length свободных блоков.
Когда системе требуется новый блок для данных, то она берет последний свободный блок из массива free\_blocks и уменьшает length на 1. Если свободных блоков нет, то он создается в конце файла базы. Блоки, содержащиеся в массиве blocks, не являются свободными, а принадлежат объекту – таблице свободных блоков. В blocks может содержаться больше блоков, чем необходимо для хранения массива free\_blocks.

**Остальные объекты.**

Вся информация в базе, кроме блока 0 и таблицы свободных блоков хранится именно в таких объектах.

В поле length содержится длина в байтах данных объекта.

В массиве blocks находятся индексы блоков, содержащих таблицу размещения данных объекта. Каждый блок, указанный в blocks, и являющийся частью таблицы размещения, имеет следующую структуру:
```
struct {
int numblocks;
unsigned int datablocks[1023];
}
```
Поле numblocks указывает количество реальных значений в datablocks (от 1 до 1023). В datablocks содержатся индексы блоков, в которых находится собственно содержимое объекта (данные). Так как в одном блоке таблицы размещения может быть указано максимум 1023 блока с данными, то соответственно, максимальная длина данных, указанных в одном блоке таблицы размещения равна 1023 `*` 4096 = 4190208 байт (0x3ff `*` 0x1000 = 0x3ff000). Таким образом, из длины содержимого объекта length мы можем определить количество фактических значений в blocks. Если length равен 0, то в blocks нет значащих данных, иначе количество значений в blocks равно (length - 1) / 0x3ff000 + 1 (деление целочисленное, без остатка). А также можно вычислить максимальную длину данных одного объекта: 4190208 `*` 1018 = 4265631744 байт (1018 – максимальное количество значений в массиве blocks), это совсем немного меньше 4х гигабайт.

Повторим, в заголовочном блоке объекта находится массив blocks, содержащий индексы блоков с таблицей размещения. А в таблице размещения находятся блоки, содержащие сами данные.

**Блок 2. Корневой объект.**

Последним объектом с предопределенным расположением является корневой объект. Заголовочный блок корневого объекта располагается в блоке с индексом 2. Все остальные объекты базы могут быть получены через корневой объект. Структура данных этого объекта зависит от версии базы, хотя и различается несильно. Для версий базы «8.0.3.0» и «8.0.5.0» эта структура выглядит так:
```
struct {
char locale[8];
int numblocks;
int tableblocks[numblocks];
}
```
Для версий «8.1.0.0», «8.2.0.0» и «8.2.14.0» структура выглядит так:
```
struct {
char locale[32];
int numblocks;
int tableblocks[numblocks];
}
```
Т.е. различаются эти структуры только длиной поля locale. В поле locale содержится код языка базы. Код языка базы представляет собой строку в ANSI-кодировке. Мне встречались только базы с кодами «ru`_`RU» и «en». locale влияет на порядок сортировки строк при построении индексов. Что такое locale, можно почитать тут [Locale](http://userguide.icu-project.org/locale).

В поле numblocks содержится количество элементов в массиве tableblocks. В массиве же tableblocks содержатся индексы заголовочных блоков объектов описания всех таблиц базы. Т.е. таблиц в базе ровно numblocks.

**Объект таблицы.**

Каждый объект таблицы, указанный в корневом объекте, содержит просто текстовое описание таблицы в Unicode. Вот пример описания таблицы:
```
{"_Reference4",0,
{"Fields",
{"_IDRREF","B",0,16,0,"CS"},
{"_VERSION","RV",0,0,0,"CS"},
{"_MARKED","L",0,0,0,"CS"},
{"_ISMETADATA","L",0,0,0,"CS"},
{"_CODE","NC",0,9,0,"CI"},
{"_DESCRIPTION","NVC",0,25,0,"CI"},
{"_FLD7","I",1,0,0,"CS"}
},
{"Indexes",
{"_IDRREFIDX",1,
{"_IDRREF",16}
},
{"_REFERENCE4_CODE_SR",0,
{"_CODE",9},
{"_IDRREF",16}
},
{"_REFERENCE4_DESCR_SR",0,
{"_DESCRIPTION",25},
{"_IDRREF",16}
}
},
{"Recordlock","0"},
{"Files",118,119,96}
}
```
Как видно из этого примера, здесь присутствуют имя таблицы (`_Reference4`), раздел описания полей таблицы (`Fields`), раздел описания индексов (`Indexes`), параметр `Recordlock` и раздел `Files`.

В разделе `Files` всегда содержатся три числа, которые содержат индексы заголовочных блоков объектов (по порядку) с записями таблицы, Blob-данными (строки неограниченной длины и двоичные данные) и индексами. Если какого-либо объекта у таблицы нет, то соответствующее число равно нулю.

В разделе `Fields` содержатся описания полей таблицы. Описание каждого поля содержит (по порядку): имя поля (`FieldName`), тип поля (`FieldType`), признак использования NULL (`NullExists`), длину (`FieldLength`), точность (`FieldPrecision`) и признак регистрочувствительности (`FieldCaseSensitive`).

Сколько байт занимает каждое поле в записи, и как его интерпретировать, зависит от параметров поля. Во-первых, если `NullExists` у поля равен 1, то первый байт поля является признаком NULL. Значение 0 этого байта означает, что поле не содержит значение (т.е. содержит NULL). В противном случае, поле содержит значение. Если же `NullExists` равен 0, то такого байта в поле нет.

Далее, размер и формат поля зависит от типа поля. Типы поля бывают такими:
  * «B» - двоичные данные. Длина поля равна `FieldLength` байт.
  * «L» - булево. Длина поля 1 байт. Нулевое значение байта означает Ложь, иначе Истина.
  * «N» - число. Длина поля в байтах равна `Цел((FieldLength + 2) / 2)`. Числа хранятся в двоично-десятичном виде. Первый полубайт означает знак числа. 0 – число отрицательное, 1 – положительное. Каждый следующий полубайт соответствует одной десятичной цифре. Всего цифр `FieldLength`. Десятичная точка находится в `FieldPrecision` цифрах справа. Например, `FieldLength = 5`, `FieldPrecision = 3`. Байты 0x18, 0x47, 0x23 означают число 84.723, а байты 0x00, 0x00, 0x91 представляют число -0.091.
  * «NC» - строка фиксированной длины. Длина поля равна `FieldLength * 2` байт. Представляет собой строку в формате Unicode (каждый символ занимает 2 байта).
  * «NVC» - строка переменной длины. Длина поля равна `FieldLength * 2 + 2` байт. Первые 2 байта содержат длину строки (максимум `FieldLength`). Оставшиеся байты представляет собой строку в формате Unicode (каждый символ занимает 2 байта).
  * «RV» - версия. Длина поля 16 байт. Предположительно содержит четыре числа int.
  * «NT» - строка неограниченной длины. Длина поля 8 байт. Первые четыре байта содержат начальный индекс блока в объекте Blob таблицы, вторые четыре – длину данных в объекте Blob. В объекте Blob содержится строка в формате Unicode.
  * «I» - двоичные данные неограниченной длины. Длина поля 8 байт. Первые четыре байта содержат начальный индекс блока в объекте Blob таблицы, вторые четыре – длину данных в объекте Blob.
  * «DT» - дата-время. Длина поля 7 байт. Содержит данные в двоично-десятичном виде. Первые 2 байта содержат четыре цифры года, третий байт – две цифры месяца, четвертый байт – день, пятый – часы, шестой – минуты и седьмой – секунды, все также по 2 цифры.

Зная теперь длину в байтах каждого поля можно посчитать общую длину одной записи таблицы и смещение каждого поля в записи. Но для этого необходимо учесть следующее. Если в описании полей таблицы нет поля с типом версия (RV), но при этом параметр `Recordlock` равен 1, то в записи присутствует дополнительное поле, которое я для себя называю короткая скрытая версия. Длина этого поля равна 8 байт. В каждой записи самый первый байт – это признак удаленности записи (признак, что запись не занята). Если этот байт равен 1, то запись свободна, а следующие 4 байта содержат индекс следующей свободной записи. Из этого следует, что запись не может быть короче пяти байт. Если же первый байт записи содержит 0, то далее в записи следуют значения полей. Причем порядок полей определяется таким образом: первым всегда идет поле версии (или описанное в разделе `Fields` с типом RV или поле скрытой короткой версии), затем все остальные поля в том порядке, как они описаны в разделе `Fields`.

**Объект записей таблицы.**

Содержимое объекта записей таблицы содержит просто массив записей. Таким образом, длина данных этого объекта всегда кратна длине одной записи. Первая (точнее нулевая) запись всегда помечена как свободная, она содержит индекс следующей свободной записи (или 0, если таких нет). Т.е. с нее начинается цепочка свободных записей таблицы.

**Объект Blob таблицы.**

Объект содержит Blob-данные таблицы (строки неограниченной длины и двоичные данные неограниченной длины). Содержимое этого объекта состоит из блоков (не путать с блоками, из которых состоит файл 1CD) длиной 256 байт (0x100). Т.е. это просто массив блоков длиной 256 каждый. Поэтому длина данных объекта всегда кратна 256. Структура каждого блока объекта такова:
```
struct {
unsigned int nextblock;
short int length;
char[250] data;
}
```
Поле `nextblock` содержит индекс следующего блока, содержащего продолжение данных, или 0, если следующего блока нет. Поле `length` содержит длину данных в этом блоке (максимум 250). Поле `data` содержит сами данные. Нулевой блок всегда считается свободным, в поле `nextblock` он содержит индекс следующего свободного блока. Таким образом, с нулевого блока начинается цепочка свободных блоков.

В записях таблицы в полях с типом «NT» и «I» содержится индекс первого блока, с которого начинаются данные, относящиеся к этому полю данной записи.

**Объект индексов таблицы.**

Описание индексов приведено в отдельной статье [Описание структуры файла индексов файловой базы 1CD](http://code.google.com/p/restoration-base-1c8/wiki/index_format)

...

С благодарностью приму любые уточнения, дополнения, сообщения об ошибках, а также любую другую информацию по теме.